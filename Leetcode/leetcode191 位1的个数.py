# -*- coding: utf-8 -*-
# @Author: Hongyu Chen
# @Date:   2019-05-27 01:14:15
# @Last Modified by:   Hongyu Chen
# @Last Modified time: 2019-05-27 13:59:13


'''
SWAR 算法求汉明重量 时间复杂度O(1)

// 计算32位二进制的汉明重量
int32_t swar(int32_t i)
{   
    i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
    i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);
    i = (i * (0x01010101) >> 24);
    return i
}


0x55555555 的二进制为 0101  0101  0101  0101  0101  0101  0101  0101
0x33333333 的二进制为 0011  0011  0011  0011  0011  0011  0011  0011
0x0F0F0F0F 的二级制为 0000  1111  0000  1111  0000  1111  0000  1111
0x00FF00FF 的二进制为 0000  0000  1111  1111  0000  0000  1111  1111
0x0000FFFF 的二进制为 0000  0000  0000  0000  1111  1111  1111  1111

0x01010101 的二进制为 0000  0001  0000  0001  0000  0001  0000  0001

1、第一步，(i & 0x55555555) + ((i >> 1) & 0x55555555)

i &0x55555555 得到 j ，j 的偶数为全为0，奇数位与 i 的奇数位相对应。

(i >> 1) & 0x55555555 得到 q ，q 的偶数位全为0，奇数位与 i 的偶数位相对应。

(i & 0x55555555) + ((i >> 1) & 0x55555555) 即 j + q 得到 z ，

z 的第 1 位 和第 2 位的二级制表示（00或01或10）就是 i 的第 1、2 位中值为 1 的数量，

这样 z 中每两位一组的二进制表示记录了 i 中对应的两位上的非 0 的个数。

2、第二步，i = (i & 0x33333333) + ((i >> 2) & 0x33333333)

该步中的 i 即上一步中得到的 z ，如果该步骤中得到的结果是 y ，

那么 y 中每四位一组的二进制表示记录了 i（最开始的那个数） 中对应的四位上的非 0 的个数。

3、第三步，同上，结果是分成四组，每组8个二进制位来表示。

4、第四步，i = (i * (0x01010101) >> 24)

第三步计算完后，其实已经分成了四组，每组八个二进制位，只要求出每组上二进制表示的值，相加的结果就是汉明重量。

二进制乘法实际上就是左移和加法，假设被乘数是a，我们将乘数分解为2^n + 2^m + 2^k ...，则乘法结果为：

a<<n + a<<m + a<<k + ...

5、第四步其实可以继续重复前面几步的模式直到16位一组， 此时移位相加后直接返回i
'''
class Solution(object):
	def hammingWeight(self, n):
		"""
		:type n: int
		:rtype: int
		"""
		n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
		n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
		n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
		n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
		n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
		
		return n

